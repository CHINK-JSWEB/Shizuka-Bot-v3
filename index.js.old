// index.js ‚Äî Jonnelbot V2 by Jonnel Soriano
const fs = require("fs");
const path = require("path");
const express = require("express");

// ‚úÖ FIXED: Correct import for ws3-fca
const ws3 = require("ws3-fca");
const login = ws3.default || ws3;

const os = require("os");
const { execSync } = require("child_process");
const axios = require("axios");

// ================= EXPRESS SERVER =================
const app = express();
const PORT = process.env.PORT || 3000;

// Simple routes
app.get("/ping", (_, res) => res.send("pong"));

// Start Express server
app.listen(PORT, () => console.log(`üöÄ Express server running on port ${PORT}`));

// üîÑ Auto-ping para manatiling online (every 4 minutes)
setInterval(() => {
  const url = `http://localhost:${PORT}/ping`;
  axios.get(url)
    .then(() => console.log("‚úÖ Self-ping successful, bot stays alive"))
    .catch(err => console.error("‚ùå Self-ping failed:", err.message));
}, 4 * 60 * 1000);

// ==================================================
// ======= ORIGINAL BOT LOGIC NAGSTART DITO ========

global.botStartTime = Date.now();
global.events = new Map();
global.commands = new Map();
const cooldowns = new Map();
const echoPath = path.join(__dirname, "echo-config.json");

// üß† System Info (Safe for Android/Termux)
const getSystemStats = () => {
  const cpus = os.cpus() || [];
  const cpuModel = cpus.length > 0 ? cpus[0].model : "Unknown CPU";
  const coreCount = cpus.length || 1;
  const load = os.loadavg()[0] || 0;
  const cpuUsage = ((load / coreCount) * 100).toFixed(2);
  const totalMem = os.totalmem() || 1;
  const freeMem = os.freemem() || 0;
  const usedMem = totalMem - freeMem;

  let diskUsed = "N/A", diskTotal = "N/A", diskPercent = "N/A";
  try {
    const df = execSync("df -h /").toString().split("\n")[1].split(/\s+/);
    diskUsed = df[2] || "N/A";
    diskTotal = df[1] || "N/A";
    diskPercent = df[4] || "N/A";
  } catch {}

  return {
    cpuModel,
    cpuUsage,
    ram: {
      usedMB: (usedMem / 1024 / 1024).toFixed(1),
      totalMB: (totalMem / 1024 / 1024).toFixed(1),
      percent: ((usedMem / totalMem) * 100).toFixed(2)
    },
    disk: { used: diskUsed, total: diskTotal, percent: diskPercent }
  };
};
global.getSystemStats = getSystemStats;

// üßæ Load Config
const loadConfig = (filePath) => {
  try {
    if (!fs.existsSync(filePath)) {
      console.error(`‚ùå Missing ${filePath}`);
      process.exit(1);
    }
    return JSON.parse(fs.readFileSync(filePath));
  } catch (err) {
    console.error(`‚ùå Error loading ${filePath}:`, err);
    process.exit(1);
  }
};

const config = loadConfig("./config.json");
const appState = loadConfig("./appState.json");
const botPrefix = config.prefix || "!";
const detectedURLs = new Set();

// üìÇ Load Events
const loadEvents = () => {
  try {
    const eventsDir = path.join(__dirname, "events");
    if (!fs.existsSync(eventsDir)) {
      console.warn("‚ö†Ô∏è Events folder not found, skipping...");
      return;
    }
    const files = fs.readdirSync(eventsDir).filter(f => f.endsWith(".js"));
    for (const file of files) {
      const event = require(`./events/${file}`);
      if (event?.config?.eventType && typeof event.run === "function") {
        for (const type of event.config.eventType) {
          if (!global.events.has(type)) global.events.set(type, []);
          global.events.get(type).push(event.run);
          console.log(`‚úÖ Loaded event type: ${type}`);
        }
      }
      if (event?.name && typeof event.execute === "function") {
        const type = event.name;
        if (!global.events.has(type)) global.events.set(type, []);
        global.events.get(type).push(event.execute);
        console.log(`‚úÖ Loaded legacy event: ${type}`);
      }
    }
  } catch (err) {
    console.error("‚ùå Error loading events:", err);
  }
};

// üìÇ Load Commands
const getAllCommandFiles = (dirPath, arrayOfFiles = []) => {
  const files = fs.readdirSync(dirPath);
  for (const file of files) {
    const fullPath = path.join(dirPath, file);
    if (fs.statSync(fullPath).isDirectory()) {
      getAllCommandFiles(fullPath, arrayOfFiles);
    } else if (file.endsWith(".js")) {
      arrayOfFiles.push(fullPath);
    }
  }
  return arrayOfFiles;
};

const loadCommands = () => {
  try {
    const cmdsDir = path.join(__dirname, "cmds");
    if (!fs.existsSync(cmdsDir)) {
      console.warn("‚ö†Ô∏è Commands folder not found, skipping...");
      return;
    }
    const commandFiles = getAllCommandFiles(cmdsDir);
    for (const file of commandFiles) {
      const cmd = require(path.resolve(file));
      const name = cmd.config?.name || cmd.name;
      const execute = cmd.execute || cmd.onStart;
      if (name && typeof execute === "function") {
        global.commands.set(name, {
          name,
          execute,
          cooldown: cmd.config?.countDown || 0,
          admin: cmd.config?.role === 1,
          usage: cmd.config?.guide?.en || '',
          version: cmd.config?.version || "1.0"
        });
        console.log(`‚úÖ Loaded command: ${name}`);
      }
    }
  } catch (err) {
    console.error("‚ùå Error loading commands:", err);
  }
};

// üîê Reset admin-only on startup
const adminFile = path.join(__dirname, "adminMode.json");
try {
  fs.writeFileSync(adminFile, JSON.stringify({ enabled: false }, null, 2));
  console.log("üîì Admin-only mode reset to OFF on startup.");
} catch (err) {
  console.error("‚ùå Failed to write adminMode.json:", err);
}

// ü§ñ Start Bot
const startBot = () => {
  login({ appState }, async (err, api) => {
    if (err) {
      console.error("‚ùå Login failed:", err);
      return;
    }

    try {
      api.setOptions({ 
        listenEvents: true,
        logLevel: "silent",
        selfListen: false,
        ...config.option
      });
      
      console.clear();
      console.log(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë        üü¢‚ö™üî¥  JONNELBOT V2 ONLINE!          ‚ïë
‚ïë         ü§ñ  AI SYSTEM ACTIVATED             ‚ïë
‚ïë      üë®‚Äçüíª  Creator: Jonnel Soriano          ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
      `);

      // üîî Bot startup notification
      const gifPath = path.join(__dirname, "assets", "indexprefix.gif");
      const botInfo = {
        body: `
üü¢‚ö™üî¥ *JONNELBOT V2 ONLINE* üü¢‚ö™üî¥
ü§ñ AI SYSTEM ACTIVATED
üë®‚Äçüíª Creator: *Jonnel Soriano üëë*
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üìå Prefix: *${botPrefix}*
‚ú® Enjoy chatting!`,
        attachment: fs.existsSync(gifPath) ? fs.createReadStream(gifPath) : undefined
      };

      if (config.ownerID) {
        api.sendMessage(botInfo, config.ownerID);
      }

      // ==== MESSAGE LISTENER ====
      const botUID = api.getCurrentUserID();

      api.listenMqtt(async (err, event) => {
        if (err) {
          console.error("‚ùå Listener error:", err);
          return;
        }
        
        if (!event || event.senderID === botUID) return;

        try {
          // üì® Handle different event types
          if (event.type === "message" || event.type === "message_reply") {
            const message = event.body || "";
            const senderID = event.senderID;
            const threadID = event.threadID;

            // üîä Echo feature
            let echoConfig = {};
            try {
              if (fs.existsSync(echoPath)) {
                echoConfig = JSON.parse(fs.readFileSync(echoPath, "utf8"));
              }
            } catch {}

            if (echoConfig[threadID]?.enabled) {
              api.sendMessage(message, threadID);
            }

            // üéØ Command handling
            if (message.startsWith(botPrefix)) {
              const args = message.slice(botPrefix.length).trim().split(/ +/);
              const commandName = args.shift().toLowerCase();
              const command = global.commands.get(commandName);

              if (command) {
                // Check admin-only mode
                let adminMode = { enabled: false };
                try {
                  if (fs.existsSync(adminFile)) {
                    adminMode = JSON.parse(fs.readFileSync(adminFile, "utf8"));
                  }
                } catch {}

                if (adminMode.enabled && senderID !== config.ownerID) {
                  return api.sendMessage("‚ö†Ô∏è Bot is in admin-only mode.", threadID);
                }

                // Cooldown check
                if (!cooldowns.has(commandName)) {
                  cooldowns.set(commandName, new Map());
                }
                const now = Date.now();
                const timestamps = cooldowns.get(commandName);
                const cooldownAmount = (command.cooldown || 3) * 1000;

                if (timestamps.has(senderID)) {
                  const expirationTime = timestamps.get(senderID) + cooldownAmount;
                  if (now < expirationTime) {
                    const timeLeft = ((expirationTime - now) / 1000).toFixed(1);
                    return api.sendMessage(
                      `‚è±Ô∏è Please wait ${timeLeft}s before using ${commandName} again.`,
                      threadID
                    );
                  }
                }

                timestamps.set(senderID, now);
                setTimeout(() => timestamps.delete(senderID), cooldownAmount);

                // Execute command
                try {
                  await command.execute({ api, event, args, config });
                } catch (cmdErr) {
                  console.error(`‚ùå Command error [${commandName}]:`, cmdErr);
                  api.sendMessage(`‚ùå Error executing ${commandName}`, threadID);
                }
              }
            }
          }

          // üì¢ Handle other events (log, reactions, etc.)
          if (global.events.has(event.type)) {
            const handlers = global.events.get(event.type);
            for (const handler of handlers) {
              try {
                await handler({ api, event, config });
              } catch (eventErr) {
                console.error(`‚ùå Event handler error [${event.type}]:`, eventErr);
              }
            }
          }
        } catch (mainErr) {
          console.error("‚ùå Main listener error:", mainErr);
        }
      });

    } catch (err) {
      console.error("‚ùå Critical bot error:", err);
    }
  });
};

// üßº Error Handling
process.on("unhandledRejection", err => console.error("‚ö†Ô∏è Unhandled Rejection:", err));
process.on("uncaughtException", err => console.error("‚ùå Uncaught Exception:", err));

// üåê Web Panel (moved to end to avoid duplicate)
app.use(express.static(path.join(__dirname, "public")));
app.get("/", (_, res) => {
  const indexHtml = path.join(__dirname, "index.html");
  if (fs.existsSync(indexHtml)) {
    res.sendFile(indexHtml);
  } else {
    res.send("Bot is running!");
  }
});

// üöÄ Launch Bot
loadEvents();
loadCommands();
startBot();